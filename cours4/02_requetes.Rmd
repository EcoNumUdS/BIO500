
---.transition

# Les requêtes

---&twocol

# Sélectionner des tables et des colonnes


*** =left


```{r}
sql_requete <- "SELECT * FROM films LIMIT 10;"

films <- dbGetQuery(con,sql_requete)
head(films)
```

*** =right

- `*` permet de ne pas spécifier une colonne en particulier.
- Cette requête retournera toutes les colonnes de la table `films`
- Note: L'instruction `LIMIT` est utiliser dans les prochaines diapos afin de permettre le rendu des requêtes sur une diapo.

---&twocol

# Sélectionner des enregistrements unique

*** =left


```{r}
sql_requete <- "SELECT DISTINCT nom, prenom
FROM acteurs LIMIT 10;"

films <- dbGetQuery(con,sql_requete)
head(films)
```

*** =right

- L'instruction `DISTINCT` permettra de retourner la combinaison unique de noms et prénoms présent dans la table acteurs.

---&twocol

# Sélectionner des tables et des colonnes

## La connexion est ouverte et toujours accessible depuis l'objet `con`.

*** =left


```{r}
sql_requete <- "
SELECT id_film, titre, annee_prod
  FROM films LIMIT 10
;"

films <- dbGetQuery(con,sql_requete)
head(films)
```

*** =right

- `SELECT` spécifie les colonnes.
- `FROM` spécifie la table.
- On peut également ajouter une `LIMIT`.
- [Documentation SQL Select](http://docs.postgresqlfr.org/9.5/sql-select.html).


---&twocol

# Ordonner la table

*** =left

```{r}
sql_requete <- "
SELECT titre, annee_prod, id_film
  FROM films ORDER BY annee_prod DESC
;"
derniers_films <- dbGetQuery(con,sql_requete)
head(derniers_films)
```

*** =right

- `ORDER BY` permet de trier par ordre croissant (`ASC`) ou décroissant (`DESC`).

---&twocol

# Critères avec `NULL`

*** =left

```{r}
sql_requete <- "
SELECT id_film, titre, annee_prod
  FROM films WHERE annee_prod IS NOT NULL
  ORDER BY annee_prod DESC
;"
annees_films <- dbGetQuery(con,sql_requete)
head(annees_films)
```

*** =right

- `WHERE`, spécifie les critères de la requête.
- `annee_prod IS NULL` permet d'obtenir seulement les films n'ayant pas d'année de production.

---&twocolw w1:55% w2:45%

# Combiner les critères

*** =left

```{r}
sql_requete <- "
SELECT id_film, titre, annee_prod
  FROM films WHERE
  (annee_prod >= 1930 AND annee_prod <= 1940)
  OR (annee_prod >= 1950 AND annee_prod <= 1960)
  ORDER BY annee_prod
;"
derniers_films <- dbGetQuery(con,sql_requete)
head(derniers_films)
```

*** =right

- Multi-critères avec `AND` et `OR`
- Les parenthèses définissent les priorités d'opérations.
- Opérateurs de comparaison: `>=`,`<=`, `=` (Valeurs numériques)
- [Documentation sur les opérateurs de comparaisons](https://www.postgresql.org/docs/9.1/static/functions-comparison.html)

---&twocolw w1:55% w2:45%

# Critères sur le texte avec `LIKE`

*** =left

```{r}
sql_requete <- "
SELECT id_film, titre, annee_prod
  FROM films WHERE titre LIKE '%Voyage%'
;"
derniers_films <- dbGetQuery(con,sql_requete)
head(derniers_films)
```

*** =right

- Rechercher dans le texte: `LIKE`
- `%`: n'importe quels caractères
- `_`: un seul caractère (exemple: `_1_` peut renvoyer `113` ou encore `A1C`)
- Le critère contraire est aussi possible avec `NOT` (exemple: `WHERE titre NOT LIKE '%voyage%'`)

---

# Exercice 4 (10 minutes)

Dans ta table `acteurs`, essayer de trouver votre acteur préféré avec `LIKE` ou avec `= 'votre_acteur_pref'`


---&twocol

# Agréger l'information (1 ligne)

*** =left

```{r}
sql_requete <- "
SELECT avg(annee_prod) AS moyenne,
  min(annee_prod), max(annee_prod)
  FROM films;"

resume_films <- dbGetQuery(con,sql_requete)
head(resume_films)
```

*** =right

- Pour faire une synthèse de l'information sur une seule ligne.
- Faire des opérations sur les champs: `max`, `min`, `sum`, `avg`, `count`.
- Renommer les colonnes avec `AS`.

---&twocol

# Agréger l'information (plusieurs lignes par groupe)

*** =left

```{r}
sql_requete <- "
SELECT count(titre) AS nb_films, annee_prod
  FROM films
  GROUP BY annee_prod;"

resume_films <- dbGetQuery(con,sql_requete)
head(resume_films)
```

*** =right

- `COUNT` permet de dénombrer le nombre de lignes.
- `GROUP BY` définit les champs sur lequel se fera l'agrégation des données.

---

# Exercice 5 (10 minutes)

À l'aide de la base de données `bd_films`, dénombrer le nombre d'acteurs par films

Quels sont les 10 acteurs les plus prolifiques?

---.transition

# Jointures entre tables

---

# Jointures entre tables

Le `INNER JOIN` est un type de jointure, renvoyant seulement les films et les acteurs ayant un identifiant `id_film` commun.

```{r}
sql_requete <- "
SELECT titre, annee_prod, films.id_film, acteurs.id_film
  FROM films
  INNER JOIN acteurs ON films.id_film = acteurs.id_film
  ;"

acteurs_films <- dbGetQuery(con,sql_requete)
head(acteurs_films,4)
```

---

# Les type de jointures

<div style='text-align:center;margin-top:10px;'>
  <img src="assets/img/sql_joins.png" width="80%"></img>
</div>


---

# Jointures entre tables

On peut spécifier la jointure avec `USING` seulement si les deux clés possèdent le même nom.

```{r}
sql_requete <- "
SELECT titre, annee_prod, nom, prenom
  FROM films
  INNER JOIN acteurs USING (id_film)
  ;"

acteurs_films <- dbGetQuery(con,sql_requete)
head(acteurs_films,4)
```


---

# Exercice 4 (10-15 minutes)

## Combien il y a d'acteurs par film depuis les 10 dernières années?

Toujours avec la même base de données,
on voudrait savoir le nombre d'acteurs par film depuis les 10 dernières années.

---

# Exercice 5 (10-15 minutes)

## Existe-t-il un film sans acteurs?

En vous servant des types de jointures, on voudrait savoir s'il existe des films sans acteurs.


---&twocolw w1:55% w2:45%

# Requêtes emboitées

*** =right

- On s'interroge sur le nombre moyen d'acteurs par années.

- Pour ce faire, on peut bâtir une requête à partir d'une autre requête.

*** =left

```{r}
sql_requete <- "
SELECT annee_prod, avg(nb_acteurs) AS moy_acteurs FROM (
  SELECT titre, annee_prod, count(nom) AS nb_acteurs
    FROM films
    INNER JOIN acteurs USING (id_film)
    GROUP BY annee_prod, titre
) AS nb_acteurs_film
GROUP BY annee_prod;"

moy_acteurs <- dbGetQuery(con,sql_requete)
head(moy_acteurs)
```

---&twocolw w1:55% w2:45%

# Filtrer les requêtes à posteriori

*** =right

- Il est possible de filtrer à posteriori sur la requête avec `HAVING`.

*** =left

```{r}
sql_requete <- "
SELECT annee_prod, avg(nb_acteurs) AS moy_acteurs FROM (
  SELECT titre, annee_prod, count(nom) AS nb_acteurs
    FROM films
    INNER JOIN acteurs USING (id_film)
    GROUP BY annee_prod, titre
) AS nb_acteurs_film
GROUP BY annee_prod
HAVING avg(nb_acteurs) > 10;"

nb_acteurs <- dbGetQuery(con,sql_requete)
head(nb_acteurs)
```

---.transition

# Sauvegarder les requêtes

---

# Sauvegarder une requête

Nous avons vu précédemment `COPY ... FROM chemin_vers_fichier` pour insérer des enregistrements dans les tables.

Il existe aussi l'instruction `COPY ... TO chemin_vers_fichier` pour sauvegarder une requête.

```sql
COPY (SELECT * FROM films WHERE titre LIKE 'A%')
TO '/home/etudiant/Documents/films_A.csv' WITH DELIMITER ';' CSV HEADER;
```

---

# Sauvegarder une requête

Afin de sauvegarder les requêtes obtenues dans R par `dbGetQuery()`, il est possible d'utiliser les fonctions d'écritures tels que `write.table()` ou encore `write.csv()`.

Il existe une façon de faire des requêtes dans `pgAdmin3` et d'en sauvegarder les résultats grâce à l'outils `Query`.

---.transition

# Les requêtes stockées

---

# Les requêtes stockées: les vues

Les vues permettent de stocker directement les requêtes à l'intérieur de la base de données afin d'interroger la vue ultérieurement.

```sql
CREATE VIEW moyenne_acteurs AS (
  SELECT annee_prod, avg(nb_acteurs) AS moy_acteurs FROM (
    SELECT titre, annee_prod, count(nom) AS nb_acteurs
      FROM films
      INNER JOIN acteurs USING (id_film)
      GROUP BY annee_prod, titre
  ) AS nb_acteurs_film
  GROUP BY annee_prod
  );
```

Il sera possible d'atteindre cette vue tout simplement avec:

```sql
SELECT * FROM moyenne_acteurs;
```

---.transition

# Manipuler les enregistrements

---

# Mettre à jour des enregistrements

Avec UPDATE

---

# Supprimer des enregistrements  

Avec DELETE
