
---
class: inverse

---
class: title-slide, middle

<style type="text/css">
  .title-slide {
    background-image: url('../assets/img/bg.jpg');
    background-color: #23373B;
    background-size: contain;
    border: 0px;
    background-position: 600px 0;
    line-height: 1;
  }
</style>

# Séance 3

<hr width="65%" align="left" size="0.3" color="orange"></hr>

## La gestion des données biologiques

<hr width="65%" align="left" size="0.3" color="orange" style="margin-bottom:40px;" alt="@Martin Sanchez"></hr>

.instructors[
  **BIO500** - Dominique Gravel
]

<img src="../assets/img/logo.png" width="8%" style="margin-top:20px;"></img>

---

# Séance 3

- Ces diapositives sont disponibles en [version web](https://econumuds.github.io/BIO500/cours2/) et en [PDF](./assets/pdf/S2-BIO500.pdf).
- L'ensemble du matériel de cours est disponible sur la page du portail [moodle](https://www.usherbrooke.ca/moodle2-cours/course/view.php?id=12189).


---

# Les grandes étapes

1. Spécifier la connexion avec le serveur
2. Créer la base de données
3. Créer les tables et spécifier les clés
4. Ajouter de l'information dans les tables
5. Faire des requêtes pour extraire l'information

---
class: inverse, center, middle

# Retour rapide sur la séance de la <br> semaine dernière

<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>

---

# Connexion au serveur

```{r eval=TRUE, echo=FALSE}
system("rm -rf ./assets/data/films.db")

```


```{r eval=TRUE, echo=TRUE, message=FALSE,results='hide'}
library(RSQLite)

con <- dbConnect(SQLite(),dbname="./assets/data/films.db")

tbl_films <- "CREATE TABLE films (
    id_film     integer,
    titre       varchar(300),
    annee   integer,
    PRIMARY KEY (id_film)
);"

dbSendQuery(con,tbl_films)
```

**Question:** Sur ce script, où sont les instructions SQL? Òu sont les commandes R?

---

# Création de la table `films`

```{r, eval=FALSE}
tbl_films <- "CREATE TABLE films (
    id_film     integer,
    titre       varchar(300),
    annee   integer,
    PRIMARY KEY (id_film)
);"

dbSendQuery(con,tbl_films)
```

---

# Création de la table `acteurs`


```{r  message=FALSE, results='hide'}
tbl_acteurs <- "CREATE TABLE acteurs (
    id_acteur   integer,
    nom         varchar(100),
    prenom      varchar(100),
    id_film     integer,
    PRIMARY KEY (id_acteur),
    FOREIGN KEY (id_film) REFERENCES films (id_film) ON DELETE CASCADE
);"

dbSendQuery(con,tbl_acteurs)
```


---
class: inverse, center, middle

# Ajouter de l'information dans les tables

<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>

---

# RSQLite - `dbWriteTable`

La librairie RSQLite peut nous aider plus facilement à accomplir cette tâche:

.font90[
```{r}
# Lecture des fichiers CSV
bd_films <- read.csv2(file='./assets/data/bd_beacon/bd_films.csv',stringsAsFactors=FALSE)
bd_acteurs <- read.csv2(file='./assets/data/bd_beacon/bd_acteurs.csv',stringsAsFactors=FALSE)

# Injection des enregistrements dans la BD
dbWriteTable(con,append=TRUE,name="films",value=bd_films, row.names=FALSE)
dbWriteTable(con,append=TRUE,name="acteurs",value=bd_acteurs, row.names=FALSE)
```
]

---

# Exercice 1 (10-15 minutes)

Ce premier exercice est important pour la suite de la séance.

1. Recréer la base de données `bd_films` avec ses deux tables `films` et `acteurs`
2. Insérer les données [bd_acteurs.csv](./assets/data/bd_beacon/bd_acteurs.csv) et [bd_films.csv](./assets/data/bd_beacon/bd_films.csv) dans les deux tables à l'aide de la commande R `dbWriteTable()`


---
class: inverse, center, middle

# Les requêtes

<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>

---

# Structure du requête

.font70[
.pull-left[
```sql
SELECT colonnes/champs
FROM table1
JOIN table2 ON table1.foreignKey = table2.primaryKey
WHERE criteres
ORDER BY colonne1 ASC
LIMIT 10;
```
]]

.pull-right[
- Les requêtes SQL sont une suite d'opérations séquentielles.
- On ne peut pas filtrer (`WHERE`) avant que les opérations `SELECT`, `FROM` et `JOIN` soit complétées.
]

---

# Sélectionner des tables et des colonnes

## La connexion est ouverte et toujours accessible depuis l'objet `con`.

.pull-left[
```{r}
sql_requete <- "
SELECT id_film, titre, annee
  FROM films LIMIT 10
;"

films <- dbGetQuery(con,sql_requete)
head(films)
```
]

.pull-right[
- `SELECT` spécifie les colonnes.
- `FROM` spécifie la table.
- On peut également ajouter une `LIMIT`.
- [Documentation SQL Select](http://docs.postgresqlfr.org/9.5/sql-select.html).
]

---

# Sélectionner des tables et des colonnes

.font80[
.pull-left[
```{r}
sql_requete <- "SELECT * FROM films LIMIT 10;"

films <- dbGetQuery(con,sql_requete)
head(films)
```
]]

.pull-right[
- `*` permet de ne pas spécifier une colonne en particulier.
- Cette requête retournera toutes les colonnes de la table `films`
- Note: L'instruction `LIMIT` est utilisée dans les prochaines diapos afin de permettre le rendu des requêtes sur une diapo.
]

---

# Sélectionner des enregistrements unique

.font80[
.pull-left[
```{r}
sql_requete <- "SELECT DISTINCT nom, prenom
FROM acteurs LIMIT 10;"

films <- dbGetQuery(con,sql_requete)
head(films)
```
]]

.pull-right[
- L'instruction `DISTINCT` permettra de retourner la combinaison unique de noms et prénoms présent dans la table acteurs.
]

---

# Ordonner la table

.font80[
.pull-left[
```{r}
sql_requete <- "
SELECT titre, annee, id_film
  FROM films ORDER BY annee DESC
;"
derniers_films <- dbGetQuery(con,sql_requete)
head(derniers_films)
```
]]

.pull-right[
- `ORDER BY` permet de trier par ordre croissant (`ASC`) ou décroissant (`DESC`).
]

---

# Critères avec `NULL`

.font80[
.pull-left[
```{r}
sql_requete <- "
SELECT id_film, titre, annee
  FROM films WHERE annee IS NOT NULL
  ORDER BY annee DESC
;"
annees_films <- dbGetQuery(con,sql_requete)
head(annees_films)
```
]]

.pull-right[
- `WHERE`, spécifie les critères de la requête.
- `annee_prod IS NULL` permet d'obtenir seulement les films n'ayant pas d'année de production.
]

---

# Combiner les critères

.font80[
.pull-left[
```{r}
sql_requete <- "
SELECT id_film, titre, annee
  FROM films WHERE
  (annee >= 1930 AND annee <= 1940)
  OR (annee >= 1950 AND annee <= 1960)
  ORDER BY annee
;"
derniers_films <- dbGetQuery(con,sql_requete)
head(derniers_films)
```
]]

.pull-right[
- Multi-critères avec `AND` et `OR`
- Les parenthèses définissent les priorités d'opérations.
- Opérateurs de comparaison: `>=`,`<=`, `=` (Valeurs numériques)
- [Documentation sur les opérateurs de comparaisons](https://www.sqlite.org/lang_expr.html)
]

---

# Critères sur le texte avec `LIKE`

.font80[
.pull-left[
```{r}
sql_requete <- "
SELECT id_film, titre, annee
  FROM films WHERE titre LIKE '%Voyage%'
;"
derniers_films <- dbGetQuery(con,sql_requete)
head(derniers_films)
```
]]

.pull-right[
- Rechercher dans le texte: `LIKE`
- `%`: n'importe quels caractères
- `_`: un seul caractère (exemple: `_1_` peut renvoyer `113` ou encore `A1C`)
- Le critère contraire est aussi possible avec `NOT` (exemple: `WHERE titre NOT LIKE '%voyage%'`)
]
---

# Exercice 2 (10 minutes)

Dans ta table `acteurs`, essayer de trouver votre acteur préféré avec `LIKE` ou avec `= 'votre_acteur_pref'`


---

# Agréger l'information (1 ligne)

.font90[
.pull-left[
```{r}
sql_requete <- "
SELECT avg(annee) AS moyenne,
  min(annee), max(annee)
  FROM films;"

resume_films <- dbGetQuery(con,sql_requete)
head(resume_films)
```
]]

.pull-right[
- Pour faire une synthèse de l'information sur une seule ligne.
- Faire des opérations sur les champs numériques: `max`, `min`, `sum`, `avg`, `count`.
- Mais aussi les opérations classiques: `*`, `/`, `-` etc.
- Renommer les colonnes avec `AS`.
]

---

# Agréger l'information

## plusieurs lignes par groupe

.font80[
.pull-left[
```{r}
sql_requete <- "
SELECT count(titre) AS nb_films, annee
  FROM films
  GROUP BY annee;"

resume_films <- dbGetQuery(con,sql_requete)
head(resume_films)
```
]]

.pull-right[
- `COUNT` permet de dénombrer le nombre de lignes.
- `GROUP BY` définit les champs sur lequel se fera l'agrégation des données.
]

---

# Exercice 3 (10 minutes)

À l'aide de la base de données `bd_films`, dénombrer le nombre d'acteurs par films

Quels sont les 10 acteurs les plus prolifiques?

---
class: inverse, center, middle

# Jointures entre tables

<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>

---

# Jointures entre tables

Le `INNER JOIN` est un type de jointure, renvoyant seulement les films et les acteurs ayant un identifiant `id_film` commun.

```{r}
sql_requete <- "
SELECT titre, annee, films.id_film, acteurs.id_film
  FROM films
  INNER JOIN acteurs ON films.id_film = acteurs.id_film
  ;"

acteurs_films <- dbGetQuery(con,sql_requete)
head(acteurs_films,4)
```


---

# Les type de jointures

.center[
  <img src="assets/img/sql_joins.png" width="80%"></img>
]

---

# Jointures entre tables

On peut spécifier la jointure avec `USING` seulement si les deux clés possèdent le même nom.

```{r}
sql_requete <- "
SELECT titre, annee, nom, prenom
  FROM films
  INNER JOIN acteurs USING (id_film)
  ;"

acteurs_films <- dbGetQuery(con,sql_requete)
head(acteurs_films,4)
```

---

# Exercice 4 (5 minutes)

## Quel film possède le plus d'acteurs?

---

# Exercice 5 (10 minutes)

## Combien il y a d'acteurs par film entre 1960 et 1980?

---

# Requêtes emboitées

.font70[
.pull-left[
```{r}
sql_requete <- "
SELECT annee, avg(nb_acteurs) AS moy_acteurs FROM (
  SELECT titre, annee, count(nom) AS nb_acteurs
    FROM films
    INNER JOIN acteurs USING (id_film)
    GROUP BY annee, titre
) AS nb_acteurs_film
GROUP BY annee;"

moy_acteurs <- dbGetQuery(con,sql_requete)
head(moy_acteurs)
```
]]

.pull-right[
- On s'interroge sur le nombre moyen d'acteurs par années.
- Pour ce faire, on peut bâtir une requête à partir d'une autre requête.
]

---

# Filtrer les requêtes à posteriori

.font70[
.pull-left[
```{r}
sql_requete <- "
SELECT annee, avg(nb_acteurs) AS moy_acteurs FROM (
  SELECT titre, annee, count(nom) AS nb_acteurs
    FROM films
    INNER JOIN acteurs USING (id_film)
    GROUP BY annee, titre
) AS nb_acteurs_film
GROUP BY annee
HAVING avg(nb_acteurs) > 10;"

nb_acteurs <- dbGetQuery(con,sql_requete)
head(nb_acteurs)
```
]]

.pull-right[
- Il est possible de filtrer à posteriori sur la requête avec `HAVING`.
]


---
class: inverse, center, middle

# Sauvegarder les requêtes

<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>

---

# Sauvegarder une requête

Afin de sauvegarder les requêtes obtenues dans R par `dbGetQuery()`, il est possible d'utiliser les fonctions d'écritures tels que `write.table()` ou encore `write.csv()`.

---
class: inverse, center, middle

# Manipuler les enregistrements

<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>

---

# Mettre à jour des enregistrements

On peut mettre à jour des enregistrements d'une table avec des critères spécifiques.

```sql
UPDATE films SET genre = 'Dramatique' WHERE genre = 'Drame';
```

**Note:** On peut pas faire de modifications d'enregistrements sur des vues, seulement sur les tables directement.

[Documentation sur la commande UPDATE](http://docs.postgresqlfr.org/8.3/sql-update.html)


---

# Supprimer des enregistrements

On peut supprimer des enregistrements d'une table avec des critères spécifiques.

```sql
DELETE FROM films WHERE genre <> 'Comédie musicale';
```

Ou sans critères, pour supprimer tous les enregistrements.

```sql
DELETE FROM films;
```

[Documentation sur la commande DELETE](http://docs.postgresqlfr.org/8.3/sql-delete.html)

---
class: inverse, center, middle

# Travail de la semaine

<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>

---

# Travail de la semaine

1. Créer la base de données

2. Injecter les données

3. Faire les requêtes suivantes :
  - Nombre de liens par étudiant
  - Décompte de liens par paire d'étudiants

4. Enregistrer le résultat des requêtes dans un fichier csv

---

# Travail de la semaine

5. En post-traitement sur R :
  - Calculer le nombre d'étudiants, le nombre de liens et la connectance du réseau
  - Calculer le nombre de liens moyens par étudiant et la variance

6. Écrire un script qui réalise les étapes 1-3 d'un bloc

Vous devez remettre les 5 scripts pour chacune de ces étapes ainsi que le script final qui les exécute l'une après l'autre.
Assurez vous que le script fonctionne sur l'ordinateur du laboratoire et également entre des utilisateurs différents.

---

# Lectures

## Débat sur le partage des données

- Poisot et al. 2014. Moving toward a sustainable ecological science: don't let data go to waste ! Ideas in Ecology and Evolution 6: 11-19
- Mills et al. 2015. Archivin Primary Data: Solutions for Long-term Studies. Trends in Ecology and Evolution.

---
class: inverse, center, middle

# Discussion

<hr width="65%" size="0.3" color="orange" style="margin-top:-20px;"></hr>
