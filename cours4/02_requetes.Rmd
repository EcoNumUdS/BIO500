
---.transition

# Les requêtes

---&twocol

# Sélectionner des tables et des colonnes

La connection est ouverte et accessible depuis l'objet `con`.

*** =left


```{r}
sql_requete <- "
SELECT id_film, titre, annee_prod
  FROM films LIMIT 10
;"

films <- dbGetQuery(con,sql_requete)
head(films)
```

*** =right

- `SELECT` spécifie les colonnes.
- `FROM` spécifie la table.
- On peut également ajouter une `LIMIT`.
- [Documentation SQL Select](http://docs.postgresqlfr.org/9.5/sql-select.html).


---&twocol

# Ordonner la table

*** =left

```{r}
sql_requete <- "
SELECT titre, annee_prod, id_film
  FROM films ORDER BY annee_prod DESC
;"
derniers_films <- dbGetQuery(con,sql_requete)
head(derniers_films)
```

*** =right

- `ORDER BY` permet de trier par odre croissant (`ASC`) ou décroissant (`DESC`).

---&twocol

# Filtrer les absences de valeurs

*** =left

```{r}
sql_requete <- "
SELECT id_film, titre, annee_prod
  FROM films WHERE annee_prod IS NOT NULL
  ORDER BY annee_prod DESC
;"
derniers_films <- dbGetQuery(con,sql_requete)
head(derniers_films)
```

*** =right

- `WHERE`, spécifie les critères de la requète.
- `IS NULL`

---&twocol

# Modifier les critères

*** =left

```{r}
sql_requete <- "
SELECT id_film, titre, annee_prod
  FROM films WHERE titre LIKE '%Voyage%'
  AND annee_prod >= 1950
;"
derniers_films <- dbGetQuery(con,sql_requete)
head(derniers_films)
```

*** =right

- Multi-critères: `AND` `OR`
- Recherche sur le texte: `LIKE`, `_`
- Opérateurs de comparaison: `>=`,`<=`, `==` (Valeurs numériques)
- https://www.postgresql.org/docs/9.1/static/functions-comparison.html

---&twocol

# Opération sur la table

*** =left

```{r}
sql_requete <- "
SELECT avg(annee_prod) AS moyenne,
  min(annee_prod), max(annee_prod)
  FROM films;"

resume_films <- dbGetQuery(con,sql_requete)
head(resume_films)
```

*** =right

- Faire des opérations sur les champs: `max`, `min`, `sum`, `avg`.
- Renommer les colonnes: `AS`.

---&twocol

# Opération sur la table

*** =left

```{r}
sql_requete <- "
SELECT count(titre) AS nb_films, annee_prod
  FROM films
  GROUP BY annee_prod;"

resume_films <- dbGetQuery(con,sql_requete)
head(resume_films)
```

*** =right

- `GROUP BY` définit les champs sur lequel se fera l'aggregation des données.

---

# Exercice

---

# Jointures entre tables

Le `INNER JOIN` est un type de jointure, renvoyant seulement les films et les acteurs ayant un identifiant `id_film` commun.

```{r}
sql_requete <- "
SELECT titre, annee_prod, films.id_film, acteurs.id_film
  FROM films
  INNER JOIN acteurs ON films.id_film = acteurs.id_film
  ;"

acteurs_films <- dbGetQuery(con,sql_requete)
head(acteurs_films,4)
```

---

# Les type de jointures

<div style='text-align:center;margin-top:10px;'>
  <img src="assets/img/sql_joins.png" width="80%"></img>
</div>


---

# Jointures entre tables

On peut spécifier la jointure avec `USING` seulement si les deux clés possèdent le même nom.

```{r}
sql_requete <- "
SELECT titre, annee_prod, nom, prenom
  FROM films
  INNER JOIN acteurs USING (id_film)
  ;"

acteurs_films <- dbGetQuery(con,sql_requete)
head(acteurs_films,4)
```


---

# Exercice 1

## Combien il y a d'acteurs par film depuis les 10 dernières années?

Toujours avec la même base de données,
on voudrait savoir le nombre d'acteurs par film depuis les 10 dernières années.

---

# Exercice 2

## Existe-t-il un film sans acteurs?

En vous servant de la base de données sur le serveur `pyrolle` et des types de jointures, on voudrait savoir s'il existe des films sans acteurs.


---

# Requêtes emboitées

On s'interroge sur le nombre moyen d'acteurs par années.
Pour ce faire, on peut batîr une requête à partir d'autre requête.

```{r}
sql_requete <- "
SELECT annee_prod, avg(nb_acteurs) AS mu FROM (
  SELECT titre, annee_prod, count(nom) AS nb_acteurs
    FROM films
    INNER JOIN acteurs USING (id_film)
    GROUP BY annee_prod, titre
) AS nb_acteurs_film
GROUP BY annee_prod;"

nb_acteurs <- dbGetQuery(con,sql_requete)
head(nb_acteurs)
```

---

# Filtrer les requêtes

 <!-- Reprendre ici -->

Avec HAVING

```{r}
sql_requete <- "
SELECT annee_prod, avg(nb_acteurs) AS mu FROM (
  SELECT titre, annee_prod, count(nom) AS nb_acteurs
    FROM films
    INNER JOIN acteurs USING (id_film)
    GROUP BY annee_prod, titre
) AS nb_acteurs_film
GROUP BY annee_prod
HAVING avg(nb_acteurs) > 10;"

nb_acteurs <- dbGetQuery(con,sql_requete)
head(nb_acteurs)
```

---.transition

# Sauvegarder les requêtes

---

# Sauvegarder une requête

Avec COPY ... TO

---

# Sauvegarder une requête

Avec RPostgreSQL

---

# Les vues

- Deux sortes
  - Vue normale
  - Vue qui se met à jour sur demande (vue matérialisé)


---.transition

# Manipuler les enregistrements

---

# Mettre à jour des enregistrements

Avec UPDATE

---

# Supprimer des enregistrements  

Avec DELETE
